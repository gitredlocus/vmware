.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::InputCallback 3"
.TH XML::LibXML::InputCallback 3 "2007-04-16" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
XML::LibXML::InputCallback \- XML::LibXML Class for Input Callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  my $input_callbacks = XML::LibXML::InputCallback->new();
\&  $input_callbacks->register_callbacks([ $match_cb1, $open_cb1, 
\&                                         $read_cb1, $close_cb1 ] );
\&  $input_callbacks->register_callbacks([ $match_cb2, $open_cb2, 
\&                                         $read_cb2, $close_cb2 ] );
\&  $input_callbacks->register_callbacks( [ $match_cb3, $open_cb3, 
\&                                          $read_cb3, $close_cb3 ] );
.Ve
.PP
.Vb 2
\&  $parser->input_callbacks( $input_callbacks );
\&  $parser->parse_file( $some_xml_file );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
You may get unexpected results if you are trying to load external documents
during libxml2 parsing if the location of the resource is not a \s-1HTTP\s0, \s-1FTP\s0 or
relative location but a absolute path for example. To get around this
limitation, you may add your own input handler to open, read and close
particular types of locations or \s-1URI\s0 classes. Using this input callback
handlers, you can handle your own custom \s-1URI\s0 schemes for example.
.PP
The input callbacks are used whenever LibXML has to get something other than
externally parsed entities from somewhere. They are implemented using a
callback stack on the Perl layer in analogy to libxml2's native callback stack.
.PP
The XML::LibXML::InputCallback class transparently registers the input
callbacks for the libxml2's parser processes.
.Sh "How does XML::LibXML::InputCallback work?"
.IX Subsection "How does XML::LibXML::InputCallback work?"
The libxml2 library offers a callback implementation as global functions only.
To work-around the troubles resulting in having only global callbacks \- for
example, if the same global callback stack is manipulated by different
applications running together in a single Apache Web-server environment \-,
XML::LibXML::InputCallback comes with a object-oriented and a function-oriented
part.
.PP
Using the function-oriented part the global callback stack of libxml2 can be
manipulated. Those functions can be used as interface to the callbacks on the
C\- and \s-1XS\s0 Layer. At the object-oriented part, operations for working with the
\&\*(L"pseudo\-localized\*(R" callback stack are implemented. Currently, you can register
and de-register callbacks on the Perl layer and initialize them on a per parser
basis.
.Sh "Using XML::LibXML::InputCallback"
.IX Subsection "Using XML::LibXML::InputCallback"
After object instantiation using the parameter-less constructor, you can
register callback groups.
.PP
.Vb 7
\&  my $input_callbacks = XML::LibXML::InputCallback->new();
\&  $input_callbacks->register_callbacks([ $match_cb1, $open_cb1, 
\&                                         $read_cb1, $close_cb1 ] );
\&  $input_callbacks->register_callbacks([ $match_cb2, $open_cb2, 
\&                                         $read_cb2, $close_cb2 ] );
\&  $input_callbacks->register_callbacks( [ $match_cb3, $open_cb3, 
\&                                          $read_cb3, $close_cb3 ] );
.Ve
.PP
.Vb 2
\&  $parser->input_callbacks( $input_callbacks );
\&  $parser->parse_file( $some_xml_file );
.Ve
.Sh "What about the old callback system prior to XML::LibXML::InputCallback?"
.IX Subsection "What about the old callback system prior to XML::LibXML::InputCallback?"
In XML::LibXML versions prior to 1.59 \- i.e. without the
XML::LibXML::InputCallback module \- you could define your callbacks either
using globally or locally. You still can do that using
XML::LibXML::InputCallback, and in addition to that you can define the
callbacks on a per parser basis!
.PP
If you use the old callback interface through global callbacks,
XML::LibXML::InputCallback will treat them with a lower priority as the ones
registered using the new interface. The global callbacks will not override the
callback groups registered using the new interface. Local callbacks are
attached to a specific parser instance, therefore they are treated with highest
priority. If the match callback of the callback group registered as local
variable is identical to one of the callback groups registered using the new
interface, that callback group will be replaced.
.PP
Users of the old callback implementation whose open callback returned a plain
string, will have to adapt their code to return a reference to that string
after upgrading to version >= 1.59. The new callback system can only deal with
the open callback returning a reference!
.SH "INTERFACE DESCRIPTION"
.IX Header "INTERFACE DESCRIPTION"
.Sh "Global Variables"
.IX Subsection "Global Variables"
.IP "\fB$_CUR_CB\fR" 4
.IX Item "$_CUR_CB"
Stores the current callback and can be used as shortcut to access the callback
stack.
.IP "\fB@_GLOBAL_CALLBACKS\fR" 4
.IX Item "@_GLOBAL_CALLBACKS"
Stores all callback groups for the current parser process.
.IP "\fB@_CB_STACK\fR" 4
.IX Item "@_CB_STACK"
Stores the currently used callback group. Used to prevent parser errors when
dealing with nested \s-1XML\s0 data.
.Sh "Global Callbacks"
.IX Subsection "Global Callbacks"
.IP "\fB_callback_match\fR" 4
.IX Item "_callback_match"
Implements the interface for the match callback at C\-level and for the
selection of the callback group from the callbacks defined at the Perl\-level.
.IP "\fB_callback_open\fR" 4
.IX Item "_callback_open"
Forwards the open callback from libxml2 to the corresponding callback function
at the Perl\-level.
.IP "\fB_callback_read\fR" 4
.IX Item "_callback_read"
Forwards the read request to the corresponding callback function at the
Perl-level and returns the result to libxml2.
.IP "\fB_callback_close\fR" 4
.IX Item "_callback_close"
Forwards the close callback from libxml2 to the corresponding callback function
at the Perl\-level..
.Sh "Class methods"
.IX Subsection "Class methods"
.IP "\fB\f(BInew()\fB\fR" 4
.IX Item "new()"
A simple constructor.
.ie n .IP "\fBregister_callbacks( [ \fB$match_cb\fB, \f(BI$open_cb\fB, \f(CB$read_cb\fB, \f(CB$close_cb\fB ])\fR" 4
.el .IP "\fBregister_callbacks( [ \f(CB$match_cb\fB, \f(CB$open_cb\fB, \f(CB$read_cb\fB, \f(CB$close_cb\fB ])\fR" 4
.IX Item "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
The four callbacks have to be given as array reference in the above order
match, open, read, close!
.ie n .IP "\fBunregister_callbacks( [ \fB$match_cb\fB, \f(BI$open_cb\fB, \f(CB$read_cb\fB, \f(CB$close_cb\fB ])\fR" 4
.el .IP "\fBunregister_callbacks( [ \f(CB$match_cb\fB, \f(CB$open_cb\fB, \f(CB$read_cb\fB, \f(CB$close_cb\fB ])\fR" 4
.IX Item "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
With no arguments given, \fIunregister_callbacks()\fR will delete the last registered
callback group from the stack. If four callbacks are passed as array reference,
the callback group to unregister will be identified by the match callback and
deleted from the callback stack. Note that if several identical match callbacks
are defined in different callback groups, \s-1ALL\s0 of them will be deleted from the
stack.
.IP "\fB\f(BIinit_callbacks()\fB\fR" 4
.IX Item "init_callbacks()"
Initializes the callback system before a parsing process.
.IP "\fB\f(BIcleanup_callbacks()\fB\fR" 4
.IX Item "cleanup_callbacks()"
Resets global variables and the libxml2 callback stack.
.IP "\fB\f(BIlib_init_callbacks()\fB\fR" 4
.IX Item "lib_init_callbacks()"
Used internally for callback registration at C\-level.
.IP "\fB\f(BIlib_cleanup_callbacks()\fB\fR" 4
.IX Item "lib_cleanup_callbacks()"
Used internally for callback resetting at the C\-level.
.SH "EXAMPLE CALLBACKS"
.IX Header "EXAMPLE CALLBACKS"
The following example is a purely fictitious example that uses a
MyScheme::Handler object that responds to methods similar to an IO::Handle.
.PP
.Vb 5
\&  # Define the four callback functions
\&  sub match_uri {
\&      my $uri = shift;
\&      return $uri =~ /^myscheme:/; # trigger our callback group at a 'myscheme' URIs
\&  }
.Ve
.PP
.Vb 5
\&  sub open_uri {
\&      my $uri = shift;
\&      my $handler = MyScheme::Handler->new($uri);
\&      return $handler;
\&  }
.Ve
.PP
.Vb 8
\&  # The returned $buffer will be parsed by the libxml2 parser
\&  sub read_uri {
\&      my $handler = shift;
\&      my $length = shift;
\&      my $buffer;
\&      read($handler, $buffer, $length);
\&      return $buffer; # $buffer will be an empty string '' if read() is done
\&  }
.Ve
.PP
.Vb 5
\&  # Close the handle associated with the resource.  
\&  sub close_uri {
\&      my $handler = shift;
\&      close($handler);
\&  }
.Ve
.PP
.Vb 4
\&  # Register them with a instance of XML::LibXML::InputCallback
\&  my $input_callbacks = XML::LibXML::InputCallback->new();
\&  $input_callbacks->register_callbacks([ \e&match_uri, \e&open_uri, 
\&                                         \e&read_uri, \e&close_uri ] );
.Ve
.PP
.Vb 2
\&  # Register the callback group at a parser instance
\&  $parser->input_callbacks( $input_callbacks );
.Ve
.PP
.Vb 2
\&  # $some_xml_file will be parsed using our callbacks 
\&  $parser->parse_file( $some_xml_file );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant, 
Christian Glahn, 
Petr Pajas, 
.SH "VERSION"
.IX Header "VERSION"
1.63
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd; 2002\-2006 Christian Glahn; 2006\-2007 Petr Pajas, All rights reserved.
