.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::XPathContext 3"
.TH XML::LibXML::XPathContext 3 "2007-04-16" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
XML::LibXML::XPathContext \- XPath Evaluation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 27
\&  my $xpc = XML::LibXML::XPathContext->new();
\&  my $xpc = XML::LibXML::XPathContext->new($node);
\&  $xpc->registerNs($prefix, $namespace_uri)
\&  $xpc->unregisterNs($prefix)
\&  $uri = $xpc->lookupNs($prefix)
\&  $xpc->registerVarLookupFunc($callback, $data)
\&  $data = $xpc->getVarLookupData();
\&  $callback = $xpc->getVarLookupFunc();
\&  $xpc->unregisterVarLookupFunc($name);
\&  $xpc->registerFunctionNS($name, $uri, $callback)
\&  $xpc->unregisterFunctionNS($name, $uri)
\&  $xpc->registerFunction($name, $callback)
\&  $xpc->unregisterFunction($name)
\&  @nodes = $xpc->findnodes($xpath)
\&  @nodes = $xpc->findnodes($xpath, $context_node )
\&  $nodelist = $xpc->findnodes($xpath, $context_node )
\&  $object = $xpc->find($xpath )
\&  $object = $xpc->find($xpath, $context_node )
\&  $value = $xpc->findvalue($xpath )
\&  $value = $xpc->findvalue($xpath, $context_node )
\&  $xpc->setContextNode($node)
\&  my $node = $xpc->getContextNode;
\&  $xpc->setContextPosition($position)
\&  my $position = $xpc->getContextPosition;
\&  $xpc->setContextSize($size)
\&  my $size = $xpc->getContextSize;
\&  $xpc->setContextNode($node)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The XML::LibXML::XPathContext class provides an almost complete interface to
libxml2's XPath implementation. With XML::LibXML::XPathContext is is possible
to evaluate XPath expressions in the context of arbitrary node, context size,
and context position, with a user-defined namespace-prefix mapping, custom
XPath functions written in Perl, and even a custom XPath variable resolver.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Sh "Namespaces"
.IX Subsection "Namespaces"
This example demonstrates \fIregisterNs()\fR method. It finds all paragraph nodes in
an \s-1XHTML\s0 document.
.PP
.Vb 3
\&  my $xc = XML::LibXML::XPathContext->new($xhtml_doc);
\&  $xc->registerNs('xhtml', 'http://www.w3.org/1999/xhtml');
\&  my @nodes = $xc->findnodes('//xhtml:p');
.Ve
.Sh "Custom XPath functions"
.IX Subsection "Custom XPath functions"
This example demonstrates \fIregisterFunction()\fR method by defining a function
filtering nodes based on a Perl regular expression:
.PP
.Vb 8
\&  sub grep_nodes { 
\&    my ($nodelist,$regexp) =  @_;
\&    my $result = XML::LibXML::NodeList->new;
\&    for my $node ($nodelist->get_nodelist()) {
\&      $result->push($node) if $node->textContent =~ $regexp;
\&    }
\&    return $result;
\&  };
.Ve
.PP
.Vb 3
\&  my $xc = XML::LibXML::XPathContext->new($node);
\&  $xc->registerFunction('grep_nodes', \e&grep_nodes);
\&  my @nodes = $xc->findnodes('//section[grep_nodes(para,"\ebsearch(ing|es)?\eb")]');
.Ve
.Sh "Variables"
.IX Subsection "Variables"
This example demonstrates \fIregisterVarLookup()\fR method. We use XPath variables to
recycle results of previous evaluations:
.PP
.Vb 4
\&  sub var_lookup {
\&    my ($varname,$ns,$data)=@_;
\&    return $data->{$varname};
\&  }
.Ve
.PP
.Vb 2
\&  my $areas = XML::LibXML->new->parse_file('areas.xml');
\&  my $empl = XML::LibXML->new->parse_file('employees.xml');
.Ve
.PP
.Vb 1
\&  my $xc = XML::LibXML::XPathContext->new($empl);
.Ve
.PP
.Vb 4
\&  my %variables = ( 
\&    A => $xc->find('/employees/employee[@salary>10000]'),
\&    B => $areas->find('/areas/area[district='Brooklyn']/street'), 
\&  );
.Ve
.PP
.Vb 3
\&  # get names of employees from $A working in an area listed in $B
\&  $xc->registerVarLookupFunc(\e&var_lookup, \e%variables);
\&  my @nodes = $xc->findnodes('$A[work_area/street = $B]/name');
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  my $xpc = XML::LibXML::XPathContext->new();
.Ve
.Sp
Creates a new XML::LibXML::XPathContext object without a context node.
.Sp
.Vb 1
\&  my $xpc = XML::LibXML::XPathContext->new($node);
.Ve
.Sp
Creates a new XML::LibXML::XPathContext object with the context node set to
\&\f(CW$node\fR.
.IP "\fBregisterNs\fR" 4
.IX Item "registerNs"
.Vb 1
\&  $xpc->registerNs($prefix, $namespace_uri)
.Ve
.Sp
Registers namespace \f(CW$prefix\fR to \f(CW$namespace_uri\fR.
.IP "\fBunregisterNs\fR" 4
.IX Item "unregisterNs"
.Vb 1
\&  $xpc->unregisterNs($prefix)
.Ve
.Sp
Unregisters namespace \f(CW$prefix\fR.
.IP "\fBlookupNs\fR" 4
.IX Item "lookupNs"
.Vb 1
\&  $uri = $xpc->lookupNs($prefix)
.Ve
.Sp
Returns namespace \s-1URI\s0 registered with \f(CW$prefix\fR. If \f(CW$prefix\fR is not registered to
any namespace \s-1URI\s0 returns undef.
.IP "\fBregisterVarLookupFunc\fR" 4
.IX Item "registerVarLookupFunc"
.Vb 1
\&  $xpc->registerVarLookupFunc($callback, $data)
.Ve
.Sp
Registers variable lookup function \f(CW$prefix\fR. The registered function is executed
by the XPath engine each time an XPath variable is evaluated. It takes three
arguments: \f(CW$data\fR, variable name, and variable ns-URI and must return one value:
a number or string or any XML::LibXML:: object that can be a result of
findnodes: Boolean, Literal, Number, Node (e.g. Document, Element, etc.), or
NodeList. For convenience, simple (non\-blessed) array references containing
only XML::LibXML::Node objects can be used instead of a XML::LibXML::NodeList.
.IP "\fBgetVarLookupData\fR" 4
.IX Item "getVarLookupData"
.Vb 1
\&  $data = $xpc->getVarLookupData();
.Ve
.Sp
Returns the data that have been associated with a variable lookup function
during a previous call to registerVarLookupFunc.
.IP "\fBgetVarLookupFunc\fR" 4
.IX Item "getVarLookupFunc"
.Vb 1
\&  $callback = $xpc->getVarLookupFunc();
.Ve
.Sp
Returns the variable lookup function previously registered with
registerVarLookupFunc.
.IP "\fBunregisterVarLookupFunc\fR" 4
.IX Item "unregisterVarLookupFunc"
.Vb 1
\&  $xpc->unregisterVarLookupFunc($name);
.Ve
.Sp
Unregisters variable lookup function and the associated lookup data.
.IP "\fBregisterFunctionNS\fR" 4
.IX Item "registerFunctionNS"
.Vb 1
\&  $xpc->registerFunctionNS($name, $uri, $callback)
.Ve
.Sp
Registers an extension function \f(CW$name\fR in \f(CW$uri\fR namespace. \f(CW$callback\fR must be a
\&\s-1CODE\s0 reference. The arguments of the callback function are either simple
scalars or XML::LibXML::* objects depending on the XPath argument types. The
function is responsible for checking the argument number and types. Result of
the callback code must be a single value of the following types: a simple
scalar (number, string) or an arbitrary XML::LibXML::* object that can be a
result of findnodes: Boolean, Literal, Number, Node (e.g. Document, Element,
etc.), or NodeList. For convenience, simple (non\-blessed) array references
containing only XML::LibXML::Node objects can be used instead of a
XML::LibXML::NodeList.
.IP "\fBunregisterFunctionNS\fR" 4
.IX Item "unregisterFunctionNS"
.Vb 1
\&  $xpc->unregisterFunctionNS($name, $uri)
.Ve
.Sp
Unregisters extension function \f(CW$name\fR in \f(CW$uri\fR namespace. Has the same effect as
passing undef as \f(CW$callback\fR to registerFunctionNS.
.IP "\fBregisterFunction\fR" 4
.IX Item "registerFunction"
.Vb 1
\&  $xpc->registerFunction($name, $callback)
.Ve
.Sp
Same as registerFunctionNS but without a namespace.
.IP "\fBunregisterFunction\fR" 4
.IX Item "unregisterFunction"
.Vb 1
\&  $xpc->unregisterFunction($name)
.Ve
.Sp
Same as unregisterFunctionNS but without a namespace.
.IP "\fBfindnodes\fR" 4
.IX Item "findnodes"
.Vb 1
\&  @nodes = $xpc->findnodes($xpath)
.Ve
.Sp
.Vb 1
\&  @nodes = $xpc->findnodes($xpath, $context_node )
.Ve
.Sp
.Vb 1
\&  $nodelist = $xpc->findnodes($xpath, $context_node )
.Ve
.Sp
Performs the xpath statement on the current node and returns the result as an
array. In scalar context returns a XML::LibXML::NodeList object. Optionally, a
node may be passed as a second argument to set the context node for the query.
.IP "\fBfind\fR" 4
.IX Item "find"
.Vb 1
\&  $object = $xpc->find($xpath )
.Ve
.Sp
.Vb 1
\&  $object = $xpc->find($xpath, $context_node )
.Ve
.Sp
Performs the xpath expression using the current node as the context of the
expression, and returns the result depending on what type of result the XPath
expression had. For example, the XPath 1 * 3 + 52 results in a
XML::LibXML::Number object being returned. Other expressions might return a
XML::LibXML::Boolean object, or a XML::LibXML::Literal object (a string). Each
of those objects uses Perl's overload feature to ``do the right thing'' in
different contexts. Optionally, a node may be passed as a second argument to
set the context node for the query.
.IP "\fBfindvalue\fR" 4
.IX Item "findvalue"
.Vb 1
\&  $value = $xpc->findvalue($xpath )
.Ve
.Sp
.Vb 1
\&  $value = $xpc->findvalue($xpath, $context_node )
.Ve
.Sp
Is exactly equivalent to:
.Sp
.Vb 1
\&  $node->find( $xpath )->to_literal;
.Ve
.Sp
That is, it returns the literal value of the results. This enables you to
ensure that you get a string back from your search, allowing certain shortcuts.
This could be used as the equivalent of <xsl:value\-of select=``some_xpath''/>.
Optionally, a node may be passed in the second argument to set the context node
for the query.
.IP "\fBsetContextNode\fR" 4
.IX Item "setContextNode"
.Vb 1
\&  $xpc->setContextNode($node)
.Ve
.Sp
Set the current context node.
.IP "\fBgetContextNode\fR" 4
.IX Item "getContextNode"
.Vb 1
\&  my $node = $xpc->getContextNode;
.Ve
.Sp
Get the current context node.
.IP "\fBsetContextPosition\fR" 4
.IX Item "setContextPosition"
.Vb 1
\&  $xpc->setContextPosition($position)
.Ve
.Sp
Set the current context position. By default, this value is \-1 (and evaluating
XPath function \fIposition()\fR in the initial context raises an XPath error), but
can be set to any value up to context size. This usually only serves to cheat
the XPath engine to return given position when \fIposition()\fR XPath function is
called. Setting this value to \-1 restores the default behavior.
.IP "\fBgetContextPosition\fR" 4
.IX Item "getContextPosition"
.Vb 1
\&  my $position = $xpc->getContextPosition;
.Ve
.Sp
Get the current context position.
.IP "\fBsetContextSize\fR" 4
.IX Item "setContextSize"
.Vb 1
\&  $xpc->setContextSize($size)
.Ve
.Sp
Set the current context size. By default, this value is \-1 (and evaluating
XPath function \fIlast()\fR in the initial context raises an XPath error), but can be
set to any non-negative value. This usually only serves to cheat the XPath
engine to return the given value when \fIlast()\fR XPath function is called. If
context size is set to 0, position is automatically also set to 0. If context
size is positive, position is automatically set to 1. Setting context size to
\&\-1 restores the default behavior.
.IP "\fBgetContextSize\fR" 4
.IX Item "getContextSize"
.Vb 1
\&  my $size = $xpc->getContextSize;
.Ve
.Sp
Get the current context size.
.IP "\fBsetContextNode\fR" 4
.IX Item "setContextNode"
.Vb 1
\&  $xpc->setContextNode($node)
.Ve
.Sp
Set the current context node.
.SH "BUGS AND CAVEATS"
.IX Header "BUGS AND CAVEATS"
XML::LibXML::XPathContext objects are reentrant, meaning that you can call
methods of an XML::LibXML::XPathContext even from XPath extension functions
registered with the same object or from a variable lookup function. On the
other hand, you should rather avoid registering new extension functions,
namespaces and a variable lookup function from within extension functions and a
variable lookup function, unless you want to experience untested behavior.
.SH "AUTHORS"
.IX Header "AUTHORS"
Ilya Martynov and Petr Pajas, based on XML::LibXML and XML::LibXSLT code by
Matt Sergeant and Christian Glahn.
.SH "HISTORICAL REMARK"
.IX Header "HISTORICAL REMARK"
Prior to XML::LibXML 1.61 this module was distributed separately for
maintenance reasons.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant, 
Christian Glahn, 
Petr Pajas, 
.SH "VERSION"
.IX Header "VERSION"
1.63
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd; 2002\-2006 Christian Glahn; 2006\-2007 Petr Pajas, All rights reserved.
