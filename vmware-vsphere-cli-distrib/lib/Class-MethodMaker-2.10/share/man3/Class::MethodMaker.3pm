.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::MethodMaker 3"
.TH Class::MethodMaker 3 "2006-12-04" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Class::MethodMaker \- Create generic methods for OO Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [qw/ foo bar baz /],
\&      new    => [qw/ new /]        ,
\&    ];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module solves the problem of having to continually write accessor
methods for your objects that perform standard tasks.
.PP
The argument to 'use' is an \fBarrayref\fR, as pairs whose \*(L"keys\*(R" are the names
of types of generic methods generated by MethodMaker and whose \*(L"values\*(R" tell
method maker what methods to make.
.PP
To override any generated methods, it is sufficient to ensure that the
overriding method is defined when Class::MethodMaker is called.  Note
that the \f(CW\*(C`use\*(C'\fR keyword introduces a \f(CW\*(C`BEGIN\*(C'\fR block, so you may need to
define (or at least declare) your overriding method in a \f(CW\*(C`BEGIN\*(C'\fR block.
.Sh "Simple Use"
.IX Subsection "Simple Use"
A simple class made with \f(CW\*(C`Class::MethodMaker\*(C'\fR looks like this:
.PP
.Vb 1
\&  package MyClass;
.Ve
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [qw/ name /],
\&      new    => [qw/ new  /],
\&    ];
.Ve
.PP
This creates a class, of which new instances may be created using \f(CW\*(C`new\*(C'\fR, each
with a single scalar component called \f(CW\*(C`name\*(C'\fR.  Name may be queried and (re)set
using the methods \f(CW\*(C`name\*(C'\fR, \f(CW\*(C`name_reset\*(C'\fR and \f(CW\*(C`name_isset\*(C'\fR:
.PP
.Vb 1
\&  package main;
.Ve
.PP
.Vb 3
\&  my $m = MyClass->new;
\&  my $n;
\&  $\e = "\en";
.Ve
.PP
.Vb 1
\&  print $m->name_isset ? "true" : "false";     # false
.Ve
.PP
.Vb 4
\&  $m->name("foo");
\&  $n = $m->name;
\&  print defined $n ? "->$n<-" : "*undef*";     # ->foo<-
\&  print $m->name_isset ? "true" : "false";     # true
.Ve
.PP
.Vb 4
\&  $m->name(undef);
\&  $n = $m->name;
\&  print defined $n ? "->$n<-" : "*undef*";     # *undef*
\&  print $m->name_isset ? "true" : "false";     # true
.Ve
.PP
.Vb 4
\&  $m->name_reset;
\&  $n = $m->name;
\&  print defined $n ? "->$n<-" : "*undef*";     # *undef*
\&  print $m->name_isset ? "true" : "false";     # false
.Ve
.PP
The available component types are scalar,
array, hash.  Certain
non-data-type utilities are also provided:
new, for constructors,
deep_copy and
copy for object copies, and
abstract for creating abstract methods.
.PP
Each of the components take common options.  These include \-static, for
per-class rather than per-instance data, \-type, to restrict the data stored
to certain types (e.g., objects of a certain class), \-forward to forward
(proxy) given methods onto components, \-default/\-default_ctor to set
default values for components, \-tie_class to tie the storage of a data type
to a given class, \-read_cb/\-store_cb to call user-defined functions on
read/store (without the overhead/complexity of ties; and allowing callbacks on
existing tie classes).
.Sh "Detailed Use"
.IX Subsection "Detailed Use"
\&\f(CW\*(C`Class::MethodMaker\*(C'\fR installs \fIcomponents\fR into a class, by means of methods
that interrogate and amend those components.  A component, sometimes referred
in other documentation as a \fIslot\fR is a group of one or more attributes
(variables) that are associated with an instance of a class (sometimes called
an object), or occasionally a class itself (often referred to as a \fIstatic\fR
component).  A component is intended as a cohesive unit of data that should
only normally be interrogated or set through the methods provided.
.PP
Given an instance of a class where each instance represents a car, examples of
components are the \f(CW\*(C`make\*(C'\fR and \f(CW\*(C`model\*(C'\fR (each of which would be a simple
scalar, a string), the engine (a simple scalar, an instance of
Engine::Combustion), and the wheels (an array of instances of Wheel).  Note
that the wheels form one component, an array.  Of course, the implementor
might instead choose to use four components, each being a scalar wheel.
.PP
To have the components created, the principle use of Class::MethodMaker is to
specify the type (data\-structure) and name of each component to the import
method of Class::MethodMaker
.PP
.Vb 1
\&  package MyClass;
.Ve
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => 'name',
\&      new    => [qw/ new /],
\&    ];
.Ve
.PP
In this example, the import is called implicitly via the \f(CW\*(C`use\*(C'\fR statement.
The components are installed in the package in effect where the import is
called.  The argument to import is arranged as pairs, where the first of each
pair is the type of the data\-structure, the second is the arguments for that
data\-structure; in the most simple case, the name of a component to install
using that data\-structure.  The second of the pair should be an arrayref if
not a simple name.
.PP
Data-structures may be repeated in the call:
.PP
.Vb 5
\&  use Class::MethodMaker
\&    [ scalar => 'name1',
\&      new    => [qw/ new /],
\&      scalar => 'name2',
\&    ];
.Ve
.PP
It is an error to attempt to install a two or more components with the same
name twice.
.PP
Options may be given to data structures to amend the nature and behaviour of
the components created.  Some options are common across all data structure
(e.g., \f(CW\*(C`static\*(C'\fR) whilst some are specific to their respective data
structures.  Option syntax is laid out in detail below.  In simple, options
are provided by way of hashrefs from option name to option value.  Options and
component names are order\-sensitive; options appearing after a component do
not affect that component.  Options only apply to the data-structure to which
they are specified.  \fBBoolean\fR options (e.g., static) may be abbreviated to
\&\-option to set, !option to unset, without a hashref.
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [+{ -type => 'File::stat' }, qw/ -static name /],
\&      new    => 'new',
\&    ];
.Ve
.PP
There are also non-data-structure methods that may be created by
Class::MethodMaker.  \f(CW\*(C`new\*(C'\fR is an example of one such value; it instead causes
a standard \f(CW\*(C`new\*(C'\fR method to be created for the calling class.  The arguments
and options syntax remains the same, but many options clearly do not apply
(e.g., \f(CW\*(C`type\*(C'\fR for \f(CW\*(C`new\*(C'\fR).
.Sh "Interaction with Superclasses"
.IX Subsection "Interaction with Superclasses"
Basically, \f(CW\*(C`Class::MethodMaker\*(C'\fR takes no notice of class hierarchies.  If you
choose to install a component x in a class B that is a subclass of class A
that already has a component x, then the methods addressing x in B will simply
override those in class A in the usual fashion.  \f(CW\*(C`Class::MethodMaker\*(C'\fR takes
no special action for this situation.  This is a feature.
.Sh "Option Syntax"
.IX Subsection "Option Syntax"
The arguments to Class::MethodMaker are passed in a single arrayref, as pairs,
with the first of each pair being the name of the data\-structure, and the
second being the arguments to that structure.
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => 'name',
\&      new    => [qw/ new /],
\&    ];
.Ve
.PP
The second of the pair may in the most simple case be a single scalar that is
the name of a component to use.
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => 'bob', ];
.Ve
.PP
For anything more complex, the second argument must itself be an
arrayreference.  Simple names within this arrayreference are again taken as
component names to use; in the following example, both \f(CW\*(C`foo\*(C'\fR and \f(CW\*(C`bar\*(C'\fR
scalar components are created:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [qw/ foo bar /], ];
.Ve
.PP
Options to the data\-structure, to change the behaviour of the component, or
methods available, etc., are specified by the presence of a hash reference in
line with the component names.  Each key of the hashref is the name of an
option; the corresponding value is the option value.  Option names are easily
recognized by a leading hyphen (\f(CW\*(C`\-\*(C'\fR) (or leading exclamation mark, \f(CW\*(C`!\*(C'\fR).
The options affect only the components named \fIafter\fR the option itself.  In
the following example, \f(CW\*(C`foo\*(C'\fR is non-static (the default), whilst bar is a
static:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => ['foo', { -static => 1 }, 'bar'], ];
.Ve
.PP
Naturally, options may be altered by later settings overriding earlier ones.
The example below has exactly the same effect as the one above:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [{ -static => 1 }, 'bar', { -static => 0 }, 'foo'], ];
.Ve
.PP
Options that are boolean (on/off) valued, such as \f(CW\*(C`\-static\*(C'\fR, may be specified
external to any hashref as \f(CW\*(C`\-optionname\*(C'\fR to set them on and \f(CW\*(C`!optionname\*(C'\fR to
set them off.  The example below has exactly the same effect as the one above:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [ qw/ -static bar !static foo /], ];
.Ve
.PP
Options that take a value, e.g., \f(CW\*(C`\-type\*(C'\fR, must be specified within a hashref:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [ +{ type => 'File::stat' }, 'bob' ], ];
.Ve
.PP
Options affect is limited by the scope of the nearest enclosing arrayref.
This particularly means that for multiple invocations of a data structure
type, options on earlier invocations do not affect later ones.  In the
following example, \f(CW\*(C`foo\*(C'\fR is non-static (the default), whilst bar is a static:
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [ qw/ -static bar /],
\&      scalar => [ 'foo' ],
\&    ];
.Ve
.PP
This is true even if later invocations do not use an arrayref.  The example
below has exactly the same effect as the one above:
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [ qw/ -static bar /],
\&      scalar => 'foo',
\&    ];
.Ve
.PP
Arrayrefs may be employed within a set of arguments for a single
data-structure to likewise limit scope.  The example below has exactly the
same effect as the one above:
.PP
.Vb 3
\&  use Class::MethodMaker
\&    [ scalar => [ [ qw/ -static bar / ], 'foo' ],
\&    ];
.Ve
.Sh "Method Renaming"
.IX Subsection "Method Renaming"
Methods may be renamed, by providing options that map from one generic name to
another.  These are identified by the presence of a '*' in the option name.
.PP
The example below installs component \f(CW\*(C`a\*(C'\fR as a scalar, but the method that
would normally be installed as \f(CW\*(C`a_get\*(C'\fR is instead installed as \f(CW\*(C`get_a\*(C'\fR, and
likewise \f(CW\*(C`set_a\*(C'\fR is installed in place of \f(CW\*(C`a_set\*(C'\fR.
.PP
.Vb 5
\&  use Class::MethodMaker
\&    [ scalar => [ { '*_get' => 'get_*',
\&                    '*_set' => 'set_*', },
\&                  'a' ],
\&    ];
.Ve
.Sh "Default & Optional Methods"
.IX Subsection "Default & Optional Methods"
Class::MethodMaker installs a number of methods by default.  Some methods,
considered to be useful only to a subset of developers are installed only on
request.  Each method is marked in the text to state whether it is installed
by default or only upon request.
.PP
To request that a non-default method is installed, one needs to rename it
(even possibly to its normal name).  So, to install the \f(CW*_get\fR method for a
scalar attribute (as \f(CW*_get\fR), the syntax is:
.PP
.Vb 3
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ scalar => [{'*_get' => '*_get'}, 'a'] ];
.Ve
.PP
The method may be installed using a non-default name using similar syntax:
.PP
.Vb 3
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ scalar => [{'*_get' => 'get_*'}, 'a'] ];
.Ve
.PP
The client may choose to not install a default method by renaming it to undef:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [{'*' => undef }, 'a'] ];
.Ve
.PP
Note Class::MethodMaker will not install a method in place of an existing
method, so if the intent is to not install a default method because the client
has their own version, an alternative to the above is to define the client
version before calling Class::MethodMaker.
.Sh "Naming & Method-Design Conventions"
.IX Subsection "Naming & Method-Design Conventions"
The standard method names are designed with predictability and class
extendibility in mind.
.PP
\fINaming\fR
.IX Subsection "Naming"
.PP
For any component \fIx\fR that Class::MethodMaker creates, the method names are
always \f(CW\*(C`x\*(C'\fR or \f(CW\*(C`x_*\*(C'\fR.  This enables predictability, for you do not need to
remember which methods are named \f(CW\*(C`x_*\*(C'\fR and which \f(CW*_x\fR, and also you can
name methods that you create by avoiding prefixing them with \f(CW\*(C`x\*(C'\fR, and so
avoid any clash with Class::MethodMaker\-generated methods (even if
Class::MethodMaker is upgraded with shiny new extra methods).
Class::MethodMaker users may rename methods (see \*(L"Method Renaming\*(R").
.PP
For any \fBdata-structure\fR component (scalar, array, hash, etc.) \fIx\fR that
Class::MethodMaker creates, the method \f(CW\*(C`x\*(C'\fR \fIsets\fR the value of that
component: i.e., overriding any existing value, not amending or modifying.
E.g., for array components, \f(CW\*(C`x\*(C'\fR does not push or pull values but all old
values are removed, and new ones placed in their stead:
.PP
.Vb 5
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ array => 'a',
\&      new   => 'new',
\&    ];
.Ve
.PP
.Vb 6
\&  package main;
\&  my $m = MyClass->new;
\&  $m->a(4,5);
\&  print join(' ', $m->a), "\en"; # 4 5
\&  $m->a(6,7);
\&  print join(' ', $m->a), "\en"; # 6 7
.Ve
.PP
The method returns the \fInew\fR value of the component:
.PP
.Vb 1
\&  print join(' ', $m->a(8,9)), "\en"; # 8 9
.Ve
.PP
Note that calling the method with an empty list \fBdoes not\fR reset the value to
empty; this is so that normal lookups work on the method (i.e., if
.PP
.Vb 1
\&  $m->a
.Ve
.PP
emptied the component, then
.PP
.Vb 1
\&  @a = $m->a
.Ve
.PP
would always give an empty list: not that useful.
.PP
\fISet/Unset\fR
.IX Subsection "Set/Unset"
.PP
Each data-structure component has the concept of being set/unset as a whole,
independent of individual members being set.  Each component starts life unset
(unless a default or default option or tie class has been supplied), and is
becomes set by any assignment.  The component is then reset with the
\&\f(CW*_reset\fR method.  Thus it is possible to distinguish between a component
that has been set to an explicitly empty value, and one that has not been set
(or been reset).  This distinction is analogous to the distinction in hashes
between a missing key and a key whose value is undef.
.PP
.Vb 5
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ new    => 'new',
\&      scalar => 'x',
\&    ];
.Ve
.PP
.Vb 2
\&  package main;
\&  my $m = MyClass->new;
.Ve
.PP
.Vb 2
\&  $\e = "\en";
\&  print $m->x_isset ? "true" : "false";    # false; components start this way
.Ve
.PP
.Vb 3
\&  my $x = $m->x;
\&  print defined $n ? "->$n<-" : '*undef*'; # *undef*
\&  print $m->x_isset ? "true" : "false";    # false; reading doesn't set
.Ve
.PP
.Vb 4
\&  $m->x(undef);
\&  $x = $m->x;
\&  print $m->x_isset ? "true" : "false";    # true;
\&  print defined $n ? "->$n<-" : '*undef*'; # ->foo<-
.Ve
.PP
.Vb 4
\&  $m->x("foo");
\&  $x = $m->x;
\&  print $m->x_isset ? "true" : "false";    # true; undef is valid value
\&  print defined $n ? "->$n<-" : '*undef*'; # *undef*
.Ve
.PP
.Vb 4
\&  $m->x_reset;
\&  $x = $m->x;
\&  print defined $n ? "->$n<-" : '*undef*'; # *undef*
\&  print $m->x_isset ? "true" : "false";    # false
.Ve
.PP
It is not an error to query the value of an unset component: the value is
undef.  Querying (any passive command, or pure function) an unset component
does not cause it to become set; only assigning (any active command, or
procedure) changes the set status of a component.
.PP
\&\s-1NOTE\s0 \s-1THAT\s0 lvalues are still experimental (as of perl 5.8.0), and so their
implementation may change r disappear in the future.  Note that lvalue use
defeats type\-checking.  This may be considered a bug, and so may be fixed if
possible at some point in the future.
.PP
\fIOther Design Considerations\fR
.IX Subsection "Other Design Considerations"
.PP
Further design goals for Class::MethodMaker version 2:
.IP "Consistency of Options" 4
.IX Item "Consistency of Options"
The options passed to components are now handled in a single place, to try to
be phrased consistently.  As many options as possible are common to all
data\-structures.
.IP "Flexibility" 4
.IX Item "Flexibility"
It is intended that all common class-construction options are supported across
all data\-types, so that e.g., defaults, ties, typing may be used with your
data-structure of choice, and combined.
.IP "Speed" 4
.IX Item "Speed"
The methods are intended to be as fast as possible, within other constraints
outlined here.
.ie n .Sh "Options to ""use""\fP/\f(CW""import"""
.el .Sh "Options to \f(CWuse\fP/\f(CWimport\fP"
.IX Subsection "Options to use/import"
.ie n .IP """\-target_class""" 4
.el .IP "\f(CW\-target_class\fR" 4
.IX Item "-target_class"
By default, the target class is determined to be the last (latest) class in
the call stack that is not a Class::MethodMaker::Engine subtype.  This is what
is wanted 99% of the time, and typical users need not worry.  However, the
target class may be set explicitly in the call to \f(CW\*(C`use\*(C'\fR/\f(CW\*(C`import\*(C'\fR:
.Sp
.Vb 6
\&  use Class::MethodMaker
\&    [ -target_class => 'X',
\&      scalar        => [qw/ a /],
\&      -target_class => 'Y',
\&      scalar        => [qw/ b /],
\&    ];
.Ve
.Sp
Note that the \f(CW\*(C`\-target_class\*(C'\fR option is order sensitive: it affects only
components requested \fIafter\fR it in the call to \f(CW\*(C`use\*(C'\fR/\f(CW\*(C`import\*(C'\fR.  As shown,
the same call may handle specify multiple target classes.  Any components
requested before the first \f(CW\*(C`\-target_class\*(C'\fR are created in the
default-determined class, as outlined above.
.Sp
Setting the target class in this way does \fBnot\fR persist over multiple calls
to \f(CW\*(C`use\*(C'\fR/\f(CW\*(C`import\*(C'\fR.  A subsequent call to either will use the
default-determined class as target (unless again overriden by
\&\f(CW\*(C`\-target_class\*(C'\fR).
.Sh "Standard Options for Data-Structure Components."
.IX Subsection "Standard Options for Data-Structure Components."
The following options are observed by all data structure components
(scalar, array,
hash).
.IP "\-static" 4
.IX Item "-static"
.Vb 3
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ scalar => [qw/ -static s /], ];
.Ve
.Sp
This option causes components to hold class\-specific, rather than
instance-specific values.  Thus:
.Sp
.Vb 9
\&  package main;
\&  my $m = MyClass->new;
\&  my $n = MyClass->new;
\&  $m->a(4,5);
\&  print join(' ', $m->a), "\en"; # 4 5
\&  print join(' ', $n->a), "\en"; # 4 5
\&  $n->a(6,7);
\&  print join(' ', $n->a), "\en"; # 6 7
\&  print join(' ', $m->a), "\en"; # 6 7
.Ve
.IP "\-type" 4
.IX Item "-type"
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [{ -type => 'File::stat' }, 'st' ]];
.Ve
.Sp
Takes the name of a class, and checks that all values assigned to the
component are of the appropriate type (uses UNIVERSAL::isa, so subtypes are
permissible).
.IP "\-forward" 4
.IX Item "-forward"
This option takes as value an arrayref (or a simple scalar).  The values
specify a list of methods that when called on an instance of the target class,
are \*(L"forwarded on\*(R" to the given component.  For example,
.Sp
.Vb 1
\&  package X;
.Ve
.Sp
.Vb 6
\&  use Class::MethodMaker
\&    [scalar => [{ -type => 'File::stat',
\&                  -forward => [qw/ mode size /], },
\&                'st1',
\&               ],
\&    ])},
.Ve
.Sp
any call of \f(CW\*(C`mode\*(C'\fR or \f(CW\*(C`size\*(C'\fR on an instance of \f(CW\*(C`X\*(C'\fR wil simply call the
method of the same name on the value stored in the component \f(CW\*(C`st1\*(C'\fR, with the
same arguments, and returns the value(s) of this call.
.Sp
Forwarding only applies to the first named component (since the methodname is
fixed, without the a componentname part).  This is because the components are
installed in the order in which they are created, and Class::MethodMaker never
overwrites a pre-existing method.  So, in the following example, \f(CW\*(C`mode\*(C'\fR and
\&\f(CW\*(C`size\*(C'\fR forward to the \f(CW\*(C`st1\*(C'\fR component, and \f(CW\*(C`read\*(C'\fR forwards to the \f(CW\*(C`st2\*(C'\fR
component.
.Sp
.Vb 11
\&  package MyClass;
\&  Class::MethodMaker->import([scalar =>
\&                                [{ -type    => 'File::stat',
\&                                   -forward => [qw/ mode
\&                                                    size /],
\&                                 },
\&                                 qw( st1 ),
\&                                 { -type    => 'IO::Handle',
\&                                   -forward => 'read', },
\&                                 qw( st2 ),
\&                                ]])},
.Ve
.Sp
Forwarding a method to a component of composite data type (e.g., array, hash)
causes the method to be mapped over the values of that component.  The
returned value is appropriate to the component type; so a method forwarded to
an array will return a list, like the array that is the component, but with
each value being the instead result of applying the forwarded method to the
corresponding value of the array.
.Sp
The following code populates the \f(CW@sizes\fR array with the sizes of
\&\fI/etc/passwd\fR, \fI/etc/group\fR, in that order.
.Sp
.Vb 4
\&  package main;
\&  my $m = MyClass->new;
\&  $m->st1("/etc/passwd", "/etc/group");
\&  my @sizes = $m->size;
.Ve
.Sp
Calling the forwarding method in a scalar context will get the same results,
but as an arrayref:
.Sp
.Vb 1
\&  my $sizes = $m->size; # [ 921, 598 ] for example
.Ve
.Sp
Likewise, forwarding to a hash component will return a hash from original key
to result of method on the corresponding component, or an equivalent hashref
in scalar context.
.IP "\-default" 4
.IX Item "-default"
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [{ -default => 7 }, 'df1' ]];
.Ve
.Sp
Takes a simple value; must be either undef or an instance of the appropriate
type if \f(CW\*(C`\-type\*(C'\fR has also been specified.  Whenever a component is new or
reset, its value(s) default to the value given.  Hence \f(CW*_isset\fR will always
return true for that component.  For compound data\-structures, the default
applies to the each element of the structure, not the compound itself.  So,
for array structures, the default applies to each element of the array, not
the array itself.
.Sp
It is an error to specify the \f(CW\*(C`\-default\*(C'\fR option and the \f(CW\*(C`\-default_ctor\*(C'\fR
option simultaneously.
.IP "\-default_ctor" 4
.IX Item "-default_ctor"
.Vb 5
\&  use Class::MethodMaker
\&    [scalar => [{ -default_ctor => sub {
\&                    Y->new(-3);
\&                  },
\&                'df2',
.Ve
.Sp
.Vb 5
\&                { -type         => 'Y',
\&                  -default_ctor => 'new' },
\&                'df3',
\&               ]
\&    ];
.Ve
.Sp
Takes a coderef to call to generate the default value.  This is called the
first time a value is required, and afterwards whenever reset is called.  The
subr is called with one argument, which is the object upon which the component
exists (or the name of the class upon which the component is created, if the
call is made on the class).
.Sp
If the \f(CW\*(C`\-type\*(C'\fR option is in effect, then the value may be a simple value,
which shall be considered the name of a method to call on the class specified
by \f(CW\*(C`\-type\*(C'\fR.
.Sp
It is an error to specify the \f(CW\*(C`\-default\*(C'\fR option and the \f(CW\*(C`\-default_ctor\*(C'\fR
option simultaneously.
.IP "\-tie_class" 4
.IX Item "-tie_class"
.Vb 10
\&  # @z is an audit trail
\&  my @z;
\&  package W;
\&  use Tie::Scalar;
\&  use base qw( Tie::StdScalar );
\&  sub TIESCALAR { push @z, [ 'TIESCALAR'     ]; $_[0]->SUPER::TIESCALAR    }
\&  sub FETCH     { push @z, [ 'FETCH'         ]; $_[0]->SUPER::FETCH        }
\&  sub STORE     { push @z, [ STORE => $_[1]  ]; $_[0]->SUPER::STORE($_[1]) }
\&  sub DESTROY   { push @z, [ 'DESTROY'       ]; $_[0]->SUPER::DESTROY      }
\&  sub UNTIE     { push @z, [ UNTIE => $_[1]  ]; $_[0]->SUPER::UNTIE($_[1]) }
.Ve
.Sp
.Vb 10
\&  package X;
\&  Class::MethodMaker->import([scalar =>
\&                                [{ -type      => 'File::stat',
\&                                   -tie_class => 'W',
\&                                   -forward   => [qw/ mode
\&                                                      size /],
\&                                 },
\&                                 qw( tie1 ),
\&                              new => 'new',
\&                             ]]);
.Ve
.Sp
This option takes a simple value as argument, which is taken be the name of a
class that is to be tied to the storage for the component, e.g., for an array
component, a class that implements the \s-1API\s0 for tied arrays is needed (see
Tie::Array for more information on this).  Likewise for scalar components,
hash components, etc.  Note that it is the component that is tied, not the
data items.
.Sp
.Vb 2
\&  package main;
\&  my $x = X->new;
.Ve
.Sp
.Vb 1
\&  # @z is empty
.Ve
.Sp
.Vb 3
\&  my $stat1 = stat "/etc/passwd";
\&  my $stat2 = stat "/etc/group";
\&  $x->tie1($stat1);
.Ve
.Sp
.Vb 1
\&  # @z is (['TIESCALAR'], ['STORE', $stat1])
.Ve
.Sp
.Vb 1
\&  my $y = $x->tie1;
.Ve
.Sp
.Vb 2
\&  # $y is $stat1
\&  # @z is (['TIESCALAR'], ['STORE', $stat1], ['FETCH'])
.Ve
.Sp
.Vb 1
\&  $x->tie1($stat2);
.Ve
.Sp
.Vb 1
\&  # @z is (['TIESCALAR'], ['STORE', $stat1], ['FETCH'], ['STORE', $stat2])
.Ve
.Sp
.Vb 1
\&  $x->tie1_reset;
.Ve
.Sp
.Vb 2
\&  # @z is (['TIESCALAR'], ['STORE', $stat1], ['FETCH'], ['STORE', $stat2],\e
\&  #        ['DESTROY'])
.Ve
.IP "\-tie_args" 4
.IX Item "-tie_args"
.Vb 8
\&  package X;
\&  Class::MethodMaker->import
\&    ([scalar => [{ -tie_class => 'V',
\&                   -tie_args  => [enum    => [qw/A B C/],
\&                                  default => 'B'],
\&                 },
\&                 qw( tie2 ),
\&                ]]);
.Ve
.Sp
This option takes an array reference, whose members are passed as arguments to
any tie invoked on the component (by virtue \f(CW\*(C`\-tie_class\*(C'\fR).  If \f(CW\*(C`\-tie_class\*(C'\fR
is not in force, this is ignored.
.Sp
As a convenience measure, a single argument may be passed directly, rather
than embedding in an array ref \-\-\- unless that arg is an array ref itself...
.IP "\-read_cb" 4
.IX Item "-read_cb"
\&\fBThe implementation of this option is incomplete\fR
.Sp
.Vb 5
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ scalar => [{ -read_cb => sub { ($_[1]||0) + 1 } }, 'rcb1' ]
\&      new    => 'new';
\&    ];
.Ve
.Sp
This option takes as argument a coderef, which is called whenever a value is
read.  It is called with two arguments: the instance upon which the method was
called, and the value stored in the component.  The return value of the given
coderef is the value which is passed to the caller of the method as the
component value.  Thus, the above example adds one to whatever the stored
value is.  Note that the value is returned to the callee, but not stored in
the object
.Sp
.Vb 5
\&  package main;
\&  my $m = MyClass->new;
\&  $m->rcb1(4);
\&  my $n = $x->rcb1; # 5
\&  my $n = $x->rcb1; # 5
.Ve
.IP "\-store_cb" 4
.IX Item "-store_cb"
\&\fBThe implementation of this option is incomplete\fR
.Sp
.Vb 5
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ scalar => [{ -store_cb => sub { $_[1] + 1 } }, 'scb1' ]
\&      new    => 'new';
\&    ];
.Ve
.Sp
This option takes as argument a coderef, which is called whenever a value is
stored.  It is called with four arguments: the instance upon which the method
was called, the value to store in the component, the name of the component,
and the previous value of the component (if any; if the given element of the
component was previously unset, only three arguments are passed).
.Sp
The return value of the given coderef is the value which is actually stored in
the component.  Thus, the above example stores 1 greater than the value passed
in.
.Sp
.Vb 4
\&  package main;
\&  my $m = MyClass->new;
\&  $m->scb1(4);
\&  my $n = $x->scb1; # 5
.Ve
.Sp
Generally, store callbacks are cheaper than read callbacks, because values are
read more often than they are stored.  But that is a generalization.  \s-1YMMV\s0.
.SH "EXPERIMENTAL & COMPATIBILITY notes"
.IX Header "EXPERIMENTAL & COMPATIBILITY notes"
Some new facilities may be marked as \s-1EXPERIMENTAL\s0 in the documentation.
These facilities are being trialled, and whilst it is hoped that they
will become mainstream code, no promises are made.  They may change or
disappear at any time.  Caveat Emptor.  The maintainer would be
delighted to hear any feedback particularly regarding such facilities,
be it good or bad, so long as it is constructive.
.PP
Some old facilities may be marked as \s-1COMPATIBILITY\s0 in the documentation.
These facilities are being maintained purely for compatibility with old
versions of this module, but will ultimately disappear.  They are normally
replaced by alternatives that are considered preferable.  Please avoid using
them, and consider amending any existing code that does use them not to.  If
you believe that their removal will cast an unacceptable pall over your life,
please contact the maintainer.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::MethodMaker::Engine, Class::MethodMaker::scalar,
Class::MethodMaker::array, Class::MethodMaker::hash,
Class::MethodMaker::V1Compat
