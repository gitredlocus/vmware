.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Parser 3"
.TH XML::LibXML::Parser 3 "2007-04-16" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
XML::LibXML::Parser \- Parsing XML Data with XML::LibXML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 30
\&  $parser = XML::LibXML->new();
\&  $doc = $parser->parse_file( $xmlfilename );
\&  $doc = $parser->parse_fh( $io_fh );
\&  $doc = $parser->parse_string( $xmlstring);
\&  $doc = $parser->parse_html_file( $htmlfile, \e%opts );
\&  $doc = $parser->parse_html_fh( $io_fh, \e%opts );
\&  $doc = $parser->parse_html_string( $htmlstring, \e%opts );
\&  $fragment = $parser->parse_balanced_chunk( $wbxmlstring );
\&  $fragment = $parser->parse_xml_chunk( $wbxmlstring );
\&  $parser->process_xincludes( $doc );
\&  $parser->processXIncludes( $doc );
\&  $parser->parse_chunk($string, $terminate);
\&  $parser->start_push();
\&  $parser->push(@data);
\&  $doc = $parser->finish_push( $recover );
\&  $parser->validation(1);
\&  $parser->recover(1);
\&  $parser->recover_silently(1);
\&  $parser->expand_entities(0);
\&  $parser->keep_blanks(0);
\&  $parser->pedantic_parser(1);
\&  $parser->line_numbers(1);
\&  $parser->load_ext_dtd(1);
\&  $parser->complete_attributes(1);
\&  $parser->expand_xinclude(1);
\&  $parser->load_catalog( $catalog_file );
\&  $parser->base_uri( $your_base_uri );
\&  $parser->gdome_dom(1);
\&  $parser->clean_namespaces( 1 );
\&  $parser->no_network(1);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::LibXML;
\&  my $parser = XML::LibXML->new();
.Ve
.PP
.Vb 4
\&  my $doc = $parser->parse_string(<<'EOT');
\&  <some-xml/>
\&  EOT
\&  my $fdoc = $parser->parse_file( $xmlfile );
.Ve
.PP
.Vb 1
\&  my $fhdoc = $parser->parse_fh( $xmlstream );
.Ve
.PP
.Vb 1
\&  my $fragment = $parser->parse_xml_chunk( $xml_wb_chunk );
.Ve
.SH "PARSING"
.IX Header "PARSING"
A \s-1XML\s0 document is read into a data structure such as a \s-1DOM\s0 tree by a piece of
software, called a parser. XML::LibXML currently provides four different parser
interfaces:
.IP "\(bu" 4
A \s-1DOM\s0 Pull-Parser
.IP "\(bu" 4
A \s-1DOM\s0 Push-Parser
.IP "\(bu" 4
A \s-1SAX\s0 Parser
.IP "\(bu" 4
A \s-1DOM\s0 based \s-1SAX\s0 Parser.
.Sh "Creating a Parser Instance"
.IX Subsection "Creating a Parser Instance"
XML::LibXML provides an \s-1OO\s0 interface to the libxml2 parser functions. Thus you
have to create a parser instance before you can parse any \s-1XML\s0 data.
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  $parser = XML::LibXML->new();
.Ve
.Sp
There is nothing much to say about the constructor. It simply creates a new
parser instance.
.Sp
Although libxml2 uses mainly global flags to alter the behaviour of the parser,
each XML::LibXML parser instance has its own flags or callbacks and does not
interfere with other instances.
.Sh "\s-1DOM\s0 Parser"
.IX Subsection "DOM Parser"
One of the common parser interfaces of XML::LibXML is the \s-1DOM\s0 parser. This
parser reads \s-1XML\s0 data into a \s-1DOM\s0 like data structure, so each tag can get
accessed and transformed.
.PP
XML::LibXML's \s-1DOM\s0 parser is not only capable to parse \s-1XML\s0 data, but also
(strict) \s-1HTML\s0 files. There are three ways to parse documents \- as a string, as
a Perl filehandle, or as a filename/URL. The return value from each is a
XML::LibXML::Document object, which is a \s-1DOM\s0 object.
.PP
All of the functions listed below will throw an exception if the document is
invalid. To prevent this causing your program exiting, wrap the call in an
eval{} block
.IP "\fBparse_file\fR" 4
.IX Item "parse_file"
.Vb 1
\&  $doc = $parser->parse_file( $xmlfilename );
.Ve
.Sp
This function parses an \s-1XML\s0 document from a file or network; \f(CW$xmlfilename\fR can
be either a filename or an \s-1URL\s0. Note that for parsing files, this function is
the fastest choice, about 6\-8 times faster then \fIparse_fh()\fR.
.IP "\fBparse_fh\fR" 4
.IX Item "parse_fh"
.Vb 1
\&  $doc = $parser->parse_fh( $io_fh );
.Ve
.Sp
\&\fIparse_fh()\fR parses a \s-1IOREF\s0 or a subclass of IO::Handle.
.Sp
Because the data comes from an open handle, libxml2's parser does not know
about the base \s-1URI\s0 of the document. To set the base \s-1URI\s0 one should use
\&\fIparse_fh()\fR as follows:
.Sp
.Vb 1
\&  my $doc = $parser->parse_fh( $io_fh, $baseuri );
.Ve
.IP "\fBparse_string\fR" 4
.IX Item "parse_string"
.Vb 1
\&  $doc = $parser->parse_string( $xmlstring);
.Ve
.Sp
This function is similar to \fIparse_fh()\fR, but it parses a \s-1XML\s0 document that is
available as a single string in memory. Again, you can pass an optional base
\&\s-1URI\s0 to the function.
.Sp
.Vb 1
\&  my $doc = $parser->parse_string( $xmlstring, $baseuri );
.Ve
.IP "\fBparse_html_file\fR" 4
.IX Item "parse_html_file"
.Vb 1
\&  $doc = $parser->parse_html_file( $htmlfile, \e%opts );
.Ve
.Sp
Similar to \fIparse_file()\fR but parses \s-1HTML\s0 (strict) documents; \f(CW$htmlfile\fR can be
filename or \s-1URL\s0.
.Sp
An optional second argument can be used to pass some options to the \s-1HTML\s0 parser
as a \s-1HASH\s0 reference. Possible options are: Possible options are: encoding and
\&\s-1URI\s0 for libxml2 < 2.6.27, and for later versions of libxml2 additionally:
recover, suppress_errors, suppress_warnings, pedantic_parser, no_blanks, and
no_network.
.IP "\fBparse_html_fh\fR" 4
.IX Item "parse_html_fh"
.Vb 1
\&  $doc = $parser->parse_html_fh( $io_fh, \e%opts );
.Ve
.Sp
Similar to \fIparse_fh()\fR but parses \s-1HTML\s0 (strict) streams.
.Sp
An optional second argument can be used to pass some options to the \s-1HTML\s0 parser
as a \s-1HASH\s0 reference. Possible options are: encoding and \s-1URI\s0 for libxml2 <
2.6.27, and for later versions of libxml2 additionally: recover,
suppress_errors, suppress_warnings, pedantic_parser, no_blanks, and no_network.
Note: encoding option may not work correctly with this function in libxml2 <
2.6.27 if the \s-1HTML\s0 file declares charset using a \s-1META\s0 tag.
.IP "\fBparse_html_string\fR" 4
.IX Item "parse_html_string"
.Vb 1
\&  $doc = $parser->parse_html_string( $htmlstring, \e%opts );
.Ve
.Sp
Similar to \fIparse_string()\fR but parses \s-1HTML\s0 (strict) strings.
.Sp
An optional second argument can be used to pass some options to the \s-1HTML\s0 parser
as a \s-1HASH\s0 reference. Possible options are: encoding and \s-1URI\s0 for libxml2 <
2.6.27, and for later versions of libxml2 additionally: recover,
suppress_errors, suppress_warnings, pedantic_parser, no_blanks, and no_network.
.PP
Parsing \s-1HTML\s0 may cause problems, especially if the ampersand ('&') is used.
This is a common problem if \s-1HTML\s0 code is parsed that contains links to
CGI\-scripts. Such links cause the parser to throw errors. In such cases libxml2
still parses the entire document as there was no error, but the error causes
XML::LibXML to stop the parsing process. However, the document is not lost.
Such \s-1HTML\s0 documents should be parsed using the recover flag. By default
recovering is deactivated.
.PP
The functions described above are implemented to parse well formed documents.
In some cases a program gets well balanced \s-1XML\s0 instead of well formed documents
(e.g. a \s-1XML\s0 fragment from a Database). With XML::LibXML it is not required to
wrap such fragments in the code, because XML::LibXML is capable even to parse
well balanced \s-1XML\s0 fragments.
.IP "\fBparse_balanced_chunk\fR" 4
.IX Item "parse_balanced_chunk"
.Vb 1
\&  $fragment = $parser->parse_balanced_chunk( $wbxmlstring );
.Ve
.Sp
This function parses a well balanced \s-1XML\s0 string into a
XML::LibXML::DocumentFragment.
.IP "\fBparse_xml_chunk\fR" 4
.IX Item "parse_xml_chunk"
.Vb 1
\&  $fragment = $parser->parse_xml_chunk( $wbxmlstring );
.Ve
.Sp
This is the old name of \fIparse_balanced_chunk()\fR. Because it may causes confusion
with the push parser interface, this function should be used anymore.
.PP
By default XML::LibXML does not process XInclude tags within a \s-1XML\s0 Document
(see options section below). XML::LibXML allows to post process a document to
expand XInclude tags.
.IP "\fBprocess_xincludes\fR" 4
.IX Item "process_xincludes"
.Vb 1
\&  $parser->process_xincludes( $doc );
.Ve
.Sp
After a document is parsed into a \s-1DOM\s0 structure, you may want to expand the
documents XInclude tags. This function processes the given document structure
and expands all XInclude tags (or throws an error) by using the flags and
callbacks of the given parser instance.
.Sp
Note that the resulting Tree contains some extra nodes (of type
\&\s-1XML_XINCLUDE_START\s0 and \s-1XML_XINCLUDE_END\s0) after successfully processing the
document. These nodes indicate where data was included into the original tree.
if the document is serialized, these extra nodes will not show up.
.Sp
Remember: A Document with processed XIncludes differs from the original
document after serialization, because the original XInclude tags will not get
restored!
.Sp
If the parser flag \*(L"expand_xincludes\*(R" is set to 1, you need not to post process
the parsed document.
.IP "\fBprocessXIncludes\fR" 4
.IX Item "processXIncludes"
.Vb 1
\&  $parser->processXIncludes( $doc );
.Ve
.Sp
This is an alias to process_xincludes, but through a \s-1JAVA\s0 like function name.
.Sh "Push Parser"
.IX Subsection "Push Parser"
XML::LibXML provides a push parser interface. Rather than pulling the data from
a given source the push parser waits for the data to be pushed into it.
.PP
This allows one to parse large documents without waiting for the parser to
finish. The interface is especially useful if a program needs to pre-process
the incoming pieces of \s-1XML\s0 (e.g. to detect document boundaries).
.PP
While XML::LibXML parse_*() functions force the data to be a well-formed \s-1XML\s0,
the push parser will take any arbitrary string that contains some \s-1XML\s0 data. The
only requirement is that all the pushed strings are together a well formed
document. With the push parser interface a program can interrupt the parsing
process as required, where the parse_*() functions give not enough flexibility.
.PP
Different to the pull parser implemented in \fIparse_fh()\fR or \fIparse_file()\fR, the
push parser is not able to find out about the documents end itself. Thus the
calling program needs to indicate explicitly when the parsing is done.
.PP
In XML::LibXML this is done by a single function:
.IP "\fBparse_chunk\fR" 4
.IX Item "parse_chunk"
.Vb 1
\&  $parser->parse_chunk($string, $terminate);
.Ve
.Sp
\&\fIparse_chunk()\fR tries to parse a given chunk of data, which isn't necessarily
well balanced data. The function takes two parameters: The chunk of data as a
string and optional a termination flag. If the termination flag is set to a
true value (e.g. 1), the parsing will be stopped and the resulting document
will be returned as the following example describes:
.Sp
.Vb 5
\&  my $parser = XML::LibXML->new;
\&  for my $string ( "<", "foo", ' bar="hello world"', "/>") {
\&       $parser->parse_chunk( $string );
\&  }
\&  my $doc = $parser->parse_chunk("", 1); # terminate the parsing
.Ve
.PP
Internally XML::LibXML provides three functions that control the push parser
process:
.IP "\fBstart_push\fR" 4
.IX Item "start_push"
.Vb 1
\&  $parser->start_push();
.Ve
.Sp
Initializes the push parser.
.IP "\fBpush\fR" 4
.IX Item "push"
.Vb 1
\&  $parser->push(@data);
.Ve
.Sp
This function pushes the data stored inside the array to libxml2's parser. Each
entry in \f(CW@data\fR must be a normal scalar!
.IP "\fBfinish_push\fR" 4
.IX Item "finish_push"
.Vb 1
\&  $doc = $parser->finish_push( $recover );
.Ve
.Sp
This function returns the result of the parsing process. If this function is
called without a parameter it will complain about non well-formed documents. If
\&\f(CW$restore\fR is 1, the push parser can be used to restore broken or non well formed
(\s-1XML\s0) documents as the following example shows:
.Sp
.Vb 7
\&  eval {
\&      $parser->push( "<foo>", "bar" );
\&      $doc = $parser->finish_push();    # will report broken XML
\&  };
\&  if ( $@ ) {
\&     # ...
\&  }
.Ve
.Sp
This can be annoying if the closing tag is missed by accident. The following
code will restore the document:
.Sp
.Vb 5
\&  eval {
\&      $parser->push( "<foo>", "bar" );
\&      $doc = $parser->finish_push(1);   # will return the data parsed
\&                                        # unless an error happened
\&  };
.Ve
.Sp
.Vb 1
\&  print $doc->toString(); # returns "<foo>bar</foo>"
.Ve
.Sp
Of course \fIfinish_push()\fR will return nothing if there was no data pushed to the
parser before.
.Sh "\s-1DOM\s0 based \s-1SAX\s0 Parser"
.IX Subsection "DOM based SAX Parser"
XML::LibXML provides a \s-1DOM\s0 based \s-1SAX\s0 parser. The \s-1SAX\s0 parser is defined in
XML::LibXML::SAX::Parser. As it is not a stream based parser, it parses
documents into a \s-1DOM\s0 and traverses the \s-1DOM\s0 tree instead.
.PP
The \s-1API\s0 of this parser is exactly the same as any other Perl \s-1SAX2\s0 parser. See
XML::SAX::Intro for details.
.PP
Aside from the regular parsing methods, you can access the \s-1DOM\s0 tree traverser
directly, using the \fIgenerate()\fR method:
.PP
.Vb 3
\&  my $doc = build_yourself_a_document();
\&  my $saxparser = $XML::LibXML::SAX::Parser->new( ... );
\&  $parser->generate( $doc );
.Ve
.PP
This is useful for serializing \s-1DOM\s0 trees, for example that you might have done
prior processing on, or that you have as a result of \s-1XSLT\s0 processing.
.PP
\&\s-1WARNING\s0
.PP
This is \s-1NOT\s0 a streaming \s-1SAX\s0 parser. As I said above, this parser reads the
entire document into a \s-1DOM\s0 and serialises it. Some people couldn't read that in
the paragraph above so I've added this warning.
.PP
If you want a streaming \s-1SAX\s0 parser look at the XML::LibXML::SAX man page
.SH "SERIALIZATION"
.IX Header "SERIALIZATION"
XML::LibXML provides some functions to serialize nodes and documents. The
serialization functions are described on the XML::LibXML::Node manpage or the
XML::LibXML::Document manpage. XML::LibXML checks three global flags that alter
the serialization process:
.IP "\(bu" 4
skipXMLDeclaration
.IP "\(bu" 4
skipDTD
.IP "\(bu" 4
setTagCompression
.PP
of that three functions only setTagCompression is available for all
serialization functions.
.PP
Because XML::LibXML does these flags not itself, one has to define them locally
as the following example shows:
.PP
.Vb 3
\&  local $XML::LibXML::skipXMLDeclaration = 1;
\&  local $XML::LibXML::skipDTD = 1;
\&  local $XML::LibXML::setTagCompression = 1;
.Ve
.PP
If skipXMLDeclaration is defined and not '0', the \s-1XML\s0 declaration is omitted
during serialization.
.PP
If skipDTD is defined and not '0', an existing \s-1DTD\s0 would not be serialized with
the document.
.PP
If setTagCompression is defined and not '0' empty tags are displayed as open
and closing tags rather than the shortcut. For example the empty tag foo will
be rendered as <foo></foo> rather than <foo/>.
.SH "PARSER OPTIONS"
.IX Header "PARSER OPTIONS"
LibXML options are global (unfortunately this is a limitation of the underlying
implementation, not this interface). They can either be set using
\&\f(CW$parser\fR\->option(...), or XML::LibXML\->option(...), both are treated in the same
manner. Note that even two parser processes will share some of the same
options, so be careful out there!
.PP
Every option returns the previous value, and can be called without parameters
to get the current value.
.IP "\fBvalidation\fR" 4
.IX Item "validation"
.Vb 1
\&  $parser->validation(1);
.Ve
.Sp
Turn validation on (or off). Defaults to off.
.IP "\fBrecover\fR" 4
.IX Item "recover"
.Vb 1
\&  $parser->recover(1);
.Ve
.Sp
Turn the parsers recover mode on (or off). Defaults to off.
.Sp
This allows one to parse broken \s-1XML\s0 data into memory. This switch will only
work with \s-1XML\s0 data rather than \s-1HTML\s0 data. Also the validation will be switched
off automatically.
.Sp
The recover mode helps to recover documents that are almost well-formed very
efficiently. That is for example a document that forgets to close the document
tag (or any other tag inside the document). The recover mode of XML::LibXML has
problems restoring documents that are more like well balanced chunks.
.Sp
XML::LibXML will only parse until the first fatal error occurs, reporting
recoverable parsing errors as warnings. To suppress these warnings use
\&\f(CW$parser\fR\->\fIrecover_silently\fR\|(1); or, equivalently, \f(CW$parser\fR\->\fIrecover\fR\|(2).
.IP "\fBrecover_silently\fR" 4
.IX Item "recover_silently"
.Vb 1
\&  $parser->recover_silently(1);
.Ve
.Sp
Turns the parser warnings off (or on). Defaults to on.
.Sp
This allows to switch off warnings printed to \s-1STDERR\s0 when parsing documents
with \fIrecover\fR\|(1).
.Sp
Please note that calling \fIrecover_silently\fR\|(0) also turns the parser recover mode
off and calling \fIrecover_silently\fR\|(1) automatically activates the parser recover
mode.
.IP "\fBexpand_entities\fR" 4
.IX Item "expand_entities"
.Vb 1
\&  $parser->expand_entities(0);
.Ve
.Sp
Turn entity expansion on or off, enabled by default. If entity expansion is
off, any external parsed entities in the document are left as entities.
Probably not very useful for most purposes.
.IP "\fBkeep_blanks\fR" 4
.IX Item "keep_blanks"
.Vb 1
\&  $parser->keep_blanks(0);
.Ve
.Sp
Allows you to turn off XML::LibXML's default behaviour of maintaining
white-space in the document.
.IP "\fBpedantic_parser\fR" 4
.IX Item "pedantic_parser"
.Vb 1
\&  $parser->pedantic_parser(1);
.Ve
.Sp
You can make XML::LibXML more pedantic if you want to.
.IP "\fBline_numbers\fR" 4
.IX Item "line_numbers"
.Vb 1
\&  $parser->line_numbers(1);
.Ve
.Sp
If this option is activated XML::LibXML will store the line number of a node.
This gives more information where a validation error occurred. It could be also
used to find out about the position of a node after parsing (see also
\&\fIXML::LibXML::Node::line_number()\fR)
.Sp
By default line numbering is switched off (0).
.IP "\fBload_ext_dtd\fR" 4
.IX Item "load_ext_dtd"
.Vb 1
\&  $parser->load_ext_dtd(1);
.Ve
.Sp
Load external \s-1DTD\s0 subsets while parsing.
.Sp
This flag is also required for \s-1DTD\s0 Validation, to provide complete attribute,
and to expand entities, regardless if the document has an internal subset. Thus
switching off external \s-1DTD\s0 loading, will disable entity expansion, validation,
and complete attributes on internal subsets as well.
.Sp
If you leave this parser flag untouched, everything will work, because the
default is 1 (activated)
.IP "\fBcomplete_attributes\fR" 4
.IX Item "complete_attributes"
.Vb 1
\&  $parser->complete_attributes(1);
.Ve
.Sp
Complete the elements attributes lists with the ones defaulted from the DTDs.
By default, this option is enabled.
.IP "\fBexpand_xinclude\fR" 4
.IX Item "expand_xinclude"
.Vb 1
\&  $parser->expand_xinclude(1);
.Ve
.Sp
Expands XIinclude tags immediately while parsing the document. This flag
assures that the parser callbacks are used while parsing the included document.
.IP "\fBload_catalog\fR" 4
.IX Item "load_catalog"
.Vb 1
\&  $parser->load_catalog( $catalog_file );
.Ve
.Sp
Will use \f(CW$catalog_file\fR as a catalog during all parsing processes. Using a
catalog will significantly speed up parsing processes if many external
resources are loaded into the parsed documents (such as DTDs or XIncludes).
.Sp
Note that catalogs will not be available if an external entity handler was
specified. At the current state it is not possible to make use of both types of
resolving systems at the same time.
.IP "\fBbase_uri\fR" 4
.IX Item "base_uri"
.Vb 1
\&  $parser->base_uri( $your_base_uri );
.Ve
.Sp
In case of parsing strings or file handles, XML::LibXML doesn't know about the
base uri of the document. To make relative references such as XIncludes work,
one has to set a separate base \s-1URI\s0, that is then used for the parsed documents.
.IP "\fBgdome_dom\fR" 4
.IX Item "gdome_dom"
.Vb 1
\&  $parser->gdome_dom(1);
.Ve
.Sp
\&\s-1THIS\s0 \s-1FLAG\s0 \s-1IS\s0 \s-1EXPERIMENTAL\s0!
.Sp
Although quite powerful XML:LibXML's \s-1DOM\s0 implementation is limited if one needs
or wants full \s-1DOM\s0 level 2 or level 3 support. \s-1XML::GDOME\s0 is based on libxml2 as
well but provides a rather complete \s-1DOM\s0 implementation by wrapping libgdome.
This allows you to make use of XML::LibXML's full parser options and
\&\s-1XML::GDOME\s0's \s-1DOM\s0 implementation at the same time.
.Sp
To make use of this function, one has to install libgdome and configure
XML::LibXML to use this library. For this you need to rebuild XML::LibXML!
.IP "\fBclean_namespaces\fR" 4
.IX Item "clean_namespaces"
.Vb 1
\&  $parser->clean_namespaces( 1 );
.Ve
.Sp
libxml2 2.6.0 and later allows to strip redundant namespace declarations from
the \s-1DOM\s0 tree. To do this, one has to set \fIclean_namespaces()\fR to 1 (\s-1TRUE\s0). By
default no namespace cleanup is done.
.IP "\fBno_network\fR" 4
.IX Item "no_network"
.Vb 1
\&  $parser->no_network(1);
.Ve
.Sp
Turn networking support on or off, enabled by default. If networking is off,
all attempts to fetch non-local resources (such as \s-1DTD\s0 or external entities)
will fail (unless custom callbacks are defined). It may be necessary to use
\&\f(CW$parser\fR\->\fIrecover\fR\|(1) for processing documents requiring such resources while
networking is off.
.SH "ERROR REPORTING"
.IX Header "ERROR REPORTING"
XML::LibXML throws exceptions during parsing, validation or XPath processing
(and some other occasions). These errors can be caught by using eval blocks.
The error then will be stored in $@.
.PP
XML::LibXML throws errors as they occurs and does not wait if a user test for
them. This is a very common misunderstanding in the use of XML::LibXML. If the
eval is omitted, XML::LibXML will always halt your script by \*(L"croaking\*(R" (see
Carp man page for details).
.PP
Also note that an increasing number of functions throw errors if bad data is
passed. If you cannot assure valid data passed to XML::LibXML you should eval
these functions.
.PP
Note: since version 1.59, \fIget_last_error()\fR is no longer available in
XML::LibXML for thread-safety reasons.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant, 
Christian Glahn, 
Petr Pajas, 
.SH "VERSION"
.IX Header "VERSION"
1.63
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd; 2002\-2006 Christian Glahn; 2006\-2007 Petr Pajas, All rights reserved.
